// Decompiled by DJ v3.7.7.81 Copyright 2004 Atanas Neshkov  Date: 09/18/2004 10:43:08 PM
// Home Page : http://members.fortunecity.com/neshkov/dj.html  - Check often for new version!
// Decompiler options: packimports(3) nonlb 
// Source File Name:   i.java

package jagex.client;

import jagex.o;
import java.awt.*;
import java.awt.image.*;
import java.io.PrintStream;

public class i
    implements ImageProducer, ImageObserver {

    public i(int j, int k, int l, Component component) {
        wk = false;
        al = false;
        gk = component;
        tk = k;
        vk = j;
        bk = yj = j;
        ck = zj = k;
        ak = j * k;
        ek = new int[j * k];
        ik = new int[l][];
        rk = new boolean[l];
        jk = new byte[l][];
        kk = new int[l][];
        lk = new int[l];
        mk = new int[l];
        pk = new int[l];
        qk = new int[l];
        nk = new int[l];
        ok = new int[l];
        if(j > 1 && k > 1 && component != null) {
            dk = new DirectColorModel(32, 0xff0000, 65280, 255);
            int i1 = yj * zj;
            for(int j1 = 0; j1 < i1; j1++)
                ek[j1] = 0;

            hk = component.createImage(this);
            vf();
            component.prepareImage(hk, component);
            vf();
            component.prepareImage(hk, component);
            vf();
            component.prepareImage(hk, component);
        }
    }

    public synchronized void wg(int j, int k) {
        if(yj > bk)
            yj = bk;
        if(zj > ck)
            zj = ck;
        yj = j;
        zj = k;
        ak = j * k;
    }

    public synchronized void addConsumer(ImageConsumer imageconsumer) {
        fk = imageconsumer;
        imageconsumer.setDimensions(yj, zj);
        imageconsumer.setProperties(null);
        imageconsumer.setColorModel(dk);
        imageconsumer.setHints(14);
    }

    public synchronized boolean isConsumer(ImageConsumer imageconsumer) {
        return fk == imageconsumer;
    }

    public synchronized void removeConsumer(ImageConsumer imageconsumer) {
        if(fk == imageconsumer)
            fk = null;
    }

    public void startProduction(ImageConsumer imageconsumer) {
        addConsumer(imageconsumer);
    }

    public void requestTopDownLeftRightResend(ImageConsumer imageconsumer) {
        System.out.println("TDLR");
    }

    public synchronized void vf() {
        if(fk == null) {
            return;
        } else {
            fk.setPixels(0, 0, yj, zj, dk, ek, 0, yj);
            fk.imageComplete(2);
            return;
        }
    }

    public void sf(int j, int k, int l, int i1) {
        if(j < 0)
            j = 0;
        if(k < 0)
            k = 0;
        if(l > yj)
            l = yj;
        if(i1 > zj)
            i1 = zj;
        uk = j;
        sk = k;
        vk = l;
        tk = i1;
    }

    public void tf() {
        uk = 0;
        sk = 0;
        vk = yj;
        tk = zj;
    }

    public void jf(Graphics g, int j, int k) {
        vf();
        g.drawImage(hk, j, k, this);
    }

    public void lf() {
        int j = yj * zj;
        if(!wk) {
            for(int k = 0; k < j; k++)
                ek[k] = 0;

            return;
        }
        int l = 0;
        for(int i1 = -zj; i1 < 0; i1 += 2) {
            for(int j1 = -yj; j1 < 0; j1++)
                ek[l++] = 0;

            l += yj;
        }

    }

    public void zf(int j, int k, int l, int i1, int j1) {
        int k1 = 256 - j1;
        int l1 = (i1 >> 16 & 0xff) * j1;
        int i2 = (i1 >> 8 & 0xff) * j1;
        int j2 = (i1 & 0xff) * j1;
        int k2 = k - l;
        if(k2 < 0)
            k2 = 0;
        int l2 = k + l;
        if(l2 >= zj)
            l2 = zj - 1;
        byte byte0 = 1;
        if(wk) {
            byte0 = 2;
            if((k2 & 1) != 0)
                k2++;
        }
        for(int i3 = k2; i3 <= l2; i3 += byte0) {
            int j3 = i3 - k;
            int k3 = (int)Math.sqrt(l * l - j3 * j3);
            int l3 = j - k3;
            if(l3 < 0)
                l3 = 0;
            int i4 = j + k3;
            if(i4 >= yj)
                i4 = yj - 1;
            int j4 = l3 + i3 * yj;
            for(int k4 = l3; k4 <= i4; k4++) {
                int l4 = (ek[j4] >> 16 & 0xff) * k1;
                int i5 = (ek[j4] >> 8 & 0xff) * k1;
                int j5 = (ek[j4] & 0xff) * k1;
                int k5 = ((l1 + l4 >> 8) << 16) + ((i2 + i5 >> 8) << 8) + (j2 + j5 >> 8);
                ek[j4++] = k5;
            }

        }

    }

    public void uf(int j, int k, int l, int i1, int j1, int k1) {
        if(j < uk) {
            l -= uk - j;
            j = uk;
        }
        if(k < sk) {
            i1 -= sk - k;
            k = sk;
        }
        if(j + l > vk)
            l = vk - j;
        if(k + i1 > tk)
            i1 = tk - k;
        int l1 = 256 - k1;
        int i2 = (j1 >> 16 & 0xff) * k1;
        int j2 = (j1 >> 8 & 0xff) * k1;
        int k2 = (j1 & 0xff) * k1;
        int l2 = yj - l;
        byte byte0 = 1;
        if(wk) {
            byte0 = 2;
            l2 += yj;
            if((k & 1) != 0) {
                k++;
                i1--;
            }
        }
        int i3 = j + k * yj;
        for(int j3 = 0; j3 < i1; j3 += byte0) {
            for(int k3 = -l; k3 < 0; k3++) {
                int l3 = (ek[i3] >> 16 & 0xff) * l1;
                int i4 = (ek[i3] >> 8 & 0xff) * l1;
                int j4 = (ek[i3] & 0xff) * l1;
                int k4 = ((i2 + l3 >> 8) << 16) + ((j2 + i4 >> 8) << 8) + (k2 + j4 >> 8);
                ek[i3++] = k4;
            }

            i3 += l2;
        }

    }

    public void hg(int j, int k, int l, int i1, int j1, int k1) {
        if(j < uk) {
            l -= uk - j;
            j = uk;
        }
        if(j + l > vk)
            l = vk - j;
        int l1 = k1 >> 16 & 0xff;
        int i2 = k1 >> 8 & 0xff;
        int j2 = k1 & 0xff;
        int k2 = j1 >> 16 & 0xff;
        int l2 = j1 >> 8 & 0xff;
        int i3 = j1 & 0xff;
        int j3 = yj - l;
        byte byte0 = 1;
        if(wk) {
            byte0 = 2;
            j3 += yj;
            if((k & 1) != 0) {
                k++;
                i1--;
            }
        }
        int k3 = j + k * yj;
        for(int l3 = 0; l3 < i1; l3 += byte0)
            if(l3 + k >= sk && l3 + k < tk) {
                int i4 = ((l1 * l3 + k2 * (i1 - l3)) / i1 << 16) + ((i2 * l3 + l2 * (i1 - l3)) / i1 << 8) + (j2 * l3 + i3 * (i1 - l3)) / i1;
                for(int j4 = -l; j4 < 0; j4++)
                    ek[k3++] = i4;

                k3 += j3;
            } else {
                k3 += yj;
            }

    }

    public void yf(int j, int k, int l, int i1, int j1) {
        if(j < uk) {
            l -= uk - j;
            j = uk;
        }
        if(k < sk) {
            i1 -= sk - k;
            k = sk;
        }
        if(j + l > vk)
            l = vk - j;
        if(k + i1 > tk)
            i1 = tk - k;
        int k1 = yj - l;
        byte byte0 = 1;
        if(wk) {
            byte0 = 2;
            k1 += yj;
            if((k & 1) != 0) {
                k++;
                i1--;
            }
        }
        int l1 = j + k * yj;
        for(int i2 = -i1; i2 < 0; i2 += byte0) {
            for(int j2 = -l; j2 < 0; j2++)
                ek[l1++] = j1;

            l1 += k1;
        }

    }

    public void qf(int j, int k, int l, int i1, int j1) {
        rg(j, k, l, j1);
        rg(j, (k + i1) - 1, l, j1);
        vg(j, k, i1, j1);
        vg((j + l) - 1, k, i1, j1);
    }

    public void rg(int j, int k, int l, int i1) {
        if(k < sk || k >= tk)
            return;
        if(j < uk) {
            l -= uk - j;
            j = uk;
        }
        if(j + l > vk)
            l = vk - j;
        int j1 = j + k * yj;
        for(int k1 = 0; k1 < l; k1++)
            ek[j1 + k1] = i1;

    }

    public void vg(int j, int k, int l, int i1) {
        if(j < uk || j >= vk)
            return;
        if(k < sk) {
            l -= sk - k;
            k = sk;
        }
        if(k + l > vk)
            l = tk - k;
        int j1 = j + k * yj;
        for(int k1 = 0; k1 < l; k1++)
            ek[j1 + k1 * yj] = i1;

    }

    public void lg(int j, int k, int l) {
        if(j < uk || k < sk || j >= vk || k >= tk) {
            return;
        } else {
            ek[j + k * yj] = l;
            return;
        }
    }

    public void ff() {
        int j = yj * zj;
        for(int k = 0; k < j; k++) {
            int l = ek[k] & 0xffffff;
            ek[k] = (l >>> 1 & 0x7f7f7f) + (l >>> 2 & 0x3f3f3f) + (l >>> 3 & 0x1f1f1f) + (l >>> 4 & 0xf0f0f);
        }

    }

    public void sg(int j, int k, int l, int i1, int j1, int k1) {
        for(int l1 = l; l1 < l + j1; l1++) {
            for(int i2 = i1; i2 < i1 + k1; i2++) {
                int j2 = 0;
                int k2 = 0;
                int l2 = 0;
                int i3 = 0;
                for(int j3 = l1 - j; j3 <= l1 + j; j3++)
                    if(j3 >= 0 && j3 < yj) {
                        for(int k3 = i2 - k; k3 <= i2 + k; k3++)
                            if(k3 >= 0 && k3 < zj) {
                                int l3 = ek[j3 + yj * k3];
                                j2 += l3 >> 16 & 0xff;
                                k2 += l3 >> 8 & 0xff;
                                l2 += l3 & 0xff;
                                i3++;
                            }

                    }

                ek[l1 + yj * i2] = (j2 / i3 << 16) + (k2 / i3 << 8) + l2 / i3;
            }

        }

    }

    public static int kg(int j, int k, int l) {
        return (j << 16) + (k << 8) + l;
    }

    public void jg() {
        for(int j = 0; j < ik.length; j++) {
            ik[j] = null;
            lk[j] = 0;
            mk[j] = 0;
            jk[j] = null;
            kk[j] = null;
        }

    }

    public void og(int j, byte abyte0[], byte abyte1[], int k) {
        int l = o.wn(abyte0, 0);
        int i1 = o.wn(abyte1, l);
        l += 2;
        int j1 = o.wn(abyte1, l);
        l += 2;
        int k1 = abyte1[l++] & 0xff;
        int ai[] = new int[k1];
        ai[0] = 0xff00ff;
        for(int l1 = 0; l1 < k1 - 1; l1++) {
            ai[l1 + 1] = ((abyte1[l] & 0xff) << 16) + ((abyte1[l + 1] & 0xff) << 8) + (abyte1[l + 2] & 0xff);
            l += 3;
        }

        int i2 = 2;
        for(int j2 = j; j2 < j + k; j2++) {
            nk[j2] = abyte1[l++] & 0xff;
            ok[j2] = abyte1[l++] & 0xff;
            lk[j2] = o.wn(abyte1, l);
            l += 2;
            mk[j2] = o.wn(abyte1, l);
            l += 2;
            int k2 = abyte1[l++] & 0xff;
            int l2 = lk[j2] * mk[j2];
            jk[j2] = new byte[l2];
            kk[j2] = ai;
            pk[j2] = i1;
            qk[j2] = j1;
            ik[j2] = null;
            rk[j2] = false;
            if(nk[j2] != 0 || ok[j2] != 0)
                rk[j2] = true;
            if(k2 == 0) {
                for(int i3 = 0; i3 < l2; i3++) {
                    jk[j2][i3] = abyte0[i2++];
                    if(jk[j2][i3] == 0)
                        rk[j2] = true;
                }

            } else
            if(k2 == 1) {
                for(int j3 = 0; j3 < lk[j2]; j3++) {
                    for(int k3 = 0; k3 < mk[j2]; k3++) {
                        jk[j2][j3 + k3 * lk[j2]] = abyte0[i2++];
                        if(jk[j2][j3 + k3 * lk[j2]] == 0)
                            rk[j2] = true;
                    }

                }

            }
        }

    }

    public void ig(byte abyte0[], int j, int k, boolean flag, int l, int i1, boolean flag1) {
        int j1 = (abyte0[13 + j] & 0xff) * 256 + (abyte0[12 + j] & 0xff);
        int k1 = (abyte0[15 + j] & 0xff) * 256 + (abyte0[14 + j] & 0xff);
        int l1 = -1;
        int ai[] = new int[256];
        for(int i2 = 0; i2 < 256; i2++) {
            ai[i2] = 0xff000000 + ((abyte0[j + 20 + i2 * 3] & 0xff) << 16) + ((abyte0[j + 19 + i2 * 3] & 0xff) << 8) + (abyte0[j + 18 + i2 * 3] & 0xff);
            if(ai[i2] == -65281)
                l1 = i2;
        }

        if(l1 == -1)
            flag = false;
        if(flag1 && flag)
            ai[l1] = ai[0];
        int j2 = j1 / l;
        int k2 = k1 / i1;
        int ai1[] = new int[j2 * k2];
        for(int l2 = 0; l2 < i1; l2++) {
            for(int i3 = 0; i3 < l; i3++) {
                int j3 = 0;
                for(int k3 = k2 * l2; k3 < k2 * (l2 + 1); k3++) {
                    for(int l3 = j2 * i3; l3 < j2 * (i3 + 1); l3++)
                        if(flag1)
                            ai1[j3++] = abyte0[j + 786 + l3 + (k1 - k3 - 1) * j1] & 0xff;
                        else
                            ai1[j3++] = ai[abyte0[j + 786 + l3 + (k1 - k3 - 1) * j1] & 0xff];

                }

                if(flag1)
                    hf(ai1, j2, k2, k++, flag, ai, l1);
                else
                    hf(ai1, j2, k2, k++, flag, null, -65281);
            }

        }

    }

    private void hf(int ai[], int j, int k, int l, boolean flag, int ai1[], int i1) {
        int j1 = 0;
        int k1 = 0;
        int l1 = j;
        int i2 = k;
        if(flag) {
label0:
            for(int j2 = 0; j2 < k; j2++) {
                for(int i3 = 0; i3 < j; i3++) {
                    int i4 = ai[i3 + j2 * j];
                    if(i4 == i1)
                        continue;
                    k1 = j2;
                    break label0;
                }

            }

label1:
            for(int j3 = 0; j3 < j; j3++) {
                for(int j4 = 0; j4 < k; j4++) {
                    int j5 = ai[j3 + j4 * j];
                    if(j5 == i1)
                        continue;
                    j1 = j3;
                    break label1;
                }

            }

label2:
            for(int k4 = k - 1; k4 >= 0; k4--) {
                for(int k5 = 0; k5 < j; k5++) {
                    int k6 = ai[k5 + k4 * j];
                    if(k6 == i1)
                        continue;
                    i2 = k4 + 1;
                    break label2;
                }

            }

label3:
            for(int l5 = j - 1; l5 >= 0; l5--) {
                for(int l6 = 0; l6 < k; l6++) {
                    int i7 = ai[l5 + l6 * j];
                    if(i7 == i1)
                        continue;
                    l1 = l5 + 1;
                    break label3;
                }

            }

        }
        lk[l] = l1 - j1;
        mk[l] = i2 - k1;
        rk[l] = flag;
        nk[l] = j1;
        ok[l] = k1;
        pk[l] = j;
        qk[l] = k;
        if(ai1 == null) {
            ik[l] = new int[(l1 - j1) * (i2 - k1)];
            int k2 = 0;
            for(int k3 = k1; k3 < i2; k3++) {
                for(int l4 = j1; l4 < l1; l4++) {
                    int i6 = ai[l4 + k3 * j];
                    if(flag) {
                        if(i6 == i1)
                            i6 = 0;
                        if(i6 == 0xff000000)
                            i6 = 0xff010101;
                    }
                    ik[l][k2++] = i6 & 0xffffff;
                }

            }

            return;
        }
        jk[l] = new byte[(l1 - j1) * (i2 - k1)];
        kk[l] = ai1;
        int l2 = 0;
        for(int l3 = k1; l3 < i2; l3++) {
            for(int i5 = j1; i5 < l1; i5++) {
                int j6 = ai[i5 + l3 * j];
                if(flag)
                    if(j6 == i1)
                        j6 = 0;
                    else
                    if(j6 == 0)
                        j6 = i1;
                jk[l][l2++] = (byte)j6;
            }

        }

    }

    public void fg(int j) {
        int k = lk[j] * mk[j];
        int ai[] = ik[j];
        int ai1[] = new int[32768];
        for(int l = 0; l < k; l++) {
            int i1 = ai[l];
            ai1[((i1 & 0xf80000) >> 9) + ((i1 & 0xf800) >> 6) + ((i1 & 0xf8) >> 3)]++;
        }

        int ai2[] = new int[256];
        ai2[0] = 0xff00ff;
        int ai3[] = new int[256];
        for(int j1 = 0; j1 < 32768; j1++) {
            int k1 = ai1[j1];
            if(k1 > ai3[255]) {
                for(int l1 = 1; l1 < 256; l1++) {
                    if(k1 <= ai3[l1])
                        continue;
                    for(int j2 = 255; j2 > l1; j2--) {
                        ai2[j2] = ai2[j2 - 1];
                        ai3[j2] = ai3[j2 - 1];
                    }

                    ai2[l1] = ((j1 & 0x7c00) << 9) + ((j1 & 0x3e0) << 6) + ((j1 & 0x1f) << 3) + 0x40404;
                    ai3[l1] = k1;
                    break;
                }

            }
            ai1[j1] = -1;
        }

        byte abyte0[] = new byte[k];
        for(int i2 = 0; i2 < k; i2++) {
            int k2 = ai[i2];
            int l2 = ((k2 & 0xf80000) >> 9) + ((k2 & 0xf800) >> 6) + ((k2 & 0xf8) >> 3);
            int i3 = ai1[l2];
            if(i3 == -1) {
                int j3 = 0x3b9ac9ff;
                int k3 = k2 >> 16 & 0xff;
                int l3 = k2 >> 8 & 0xff;
                int i4 = k2 & 0xff;
                for(int j4 = 0; j4 < 256; j4++) {
                    int k4 = ai2[j4];
                    int l4 = k4 >> 16 & 0xff;
                    int i5 = k4 >> 8 & 0xff;
                    int j5 = k4 & 0xff;
                    int k5 = (k3 - l4) * (k3 - l4) + (l3 - i5) * (l3 - i5) + (i4 - j5) * (i4 - j5);
                    if(k5 < j3) {
                        j3 = k5;
                        i3 = j4;
                    }
                }

                ai1[l2] = i3;
            }
            abyte0[i2] = (byte)i3;
        }

        jk[j] = abyte0;
        kk[j] = ai2;
        ik[j] = null;
    }

    public void zg(int j) {
        if(jk[j] == null)
            return;
        int k = lk[j] * mk[j];
        byte abyte0[] = jk[j];
        int ai[] = kk[j];
        int ai1[] = new int[k];
        for(int l = 0; l < k; l++) {
            int i1 = ai[abyte0[l] & 0xff];
            if(i1 == 0)
                i1 = 1;
            else
            if(i1 == 0xff00ff)
                i1 = 0;
            ai1[l] = i1;
        }

        ik[j] = ai1;
        jk[j] = null;
        kk[j] = null;
    }

    public void kf(int j, int k, int l, int i1, int j1) {
        lk[j] = i1;
        mk[j] = j1;
        rk[j] = false;
        nk[j] = 0;
        ok[j] = 0;
        pk[j] = i1;
        qk[j] = j1;
        int k1 = i1 * j1;
        int l1 = 0;
        ik[j] = new int[k1];
        for(int i2 = k; i2 < k + i1; i2++) {
            for(int j2 = l; j2 < l + j1; j2++)
                ik[j][l1++] = ek[i2 + j2 * yj];

        }

    }

    public void rf(int j, int k, int l, int i1, int j1) {
        lk[j] = i1;
        mk[j] = j1;
        rk[j] = false;
        nk[j] = 0;
        ok[j] = 0;
        pk[j] = i1;
        qk[j] = j1;
        int k1 = i1 * j1;
        int l1 = 0;
        ik[j] = new int[k1];
        for(int i2 = l; i2 < l + j1; i2++) {
            for(int j2 = k; j2 < k + i1; j2++)
                ik[j][l1++] = ek[j2 + i2 * yj];

        }

    }

    public void xg(int j, int k, int l) {
        if(rk[l]) {
            j += nk[l];
            k += ok[l];
        }
        int i1 = j + k * yj;
        int j1 = 0;
        int k1 = mk[l];
        int l1 = lk[l];
        int i2 = yj - l1;
        int j2 = 0;
        if(k < sk) {
            int k2 = sk - k;
            k1 -= k2;
            k = sk;
            j1 += k2 * l1;
            i1 += k2 * yj;
        }
        if(k + k1 >= tk)
            k1 -= ((k + k1) - tk) + 1;
        if(j < uk) {
            int l2 = uk - j;
            l1 -= l2;
            j = uk;
            j1 += l2;
            i1 += l2;
            j2 += l2;
            i2 += l2;
        }
        if(j + l1 >= vk) {
            int i3 = ((j + l1) - vk) + 1;
            l1 -= i3;
            j2 += i3;
            i2 += i3;
        }
        if(l1 <= 0 || k1 <= 0)
            return;
        byte byte0 = 1;
        if(wk) {
            byte0 = 2;
            i2 += yj;
            j2 += lk[l];
            if((k & 1) != 0) {
                i1 += yj;
                k1--;
            }
        }
        if(ik[l] == null) {
            cg(ek, jk[l], kk[l], j1, i1, l1, k1, i2, j2, byte0);
            return;
        } else {
            gf(ek, ik[l], 0, j1, i1, l1, k1, i2, j2, byte0);
            return;
        }
    }

    public void nf(int j, int k, int l, int i1, int j1) {
        try {
            int k1 = lk[j1];
            int l1 = mk[j1];
            int i2 = 0;
            int j2 = 0;
            int k2 = (k1 << 16) / l;
            int l2 = (l1 << 16) / i1;
            if(rk[j1]) {
                int i3 = pk[j1];
                int k3 = qk[j1];
                k2 = (i3 << 16) / l;
                l2 = (k3 << 16) / i1;
                j += ((nk[j1] * l + i3) - 1) / i3;
                k += ((ok[j1] * i1 + k3) - 1) / k3;
                if((nk[j1] * l) % i3 != 0)
                    i2 = (i3 - (nk[j1] * l) % i3 << 16) / l;
                if((ok[j1] * i1) % k3 != 0)
                    j2 = (k3 - (ok[j1] * i1) % k3 << 16) / i1;
                l = (l * (lk[j1] - (i2 >> 16))) / i3;
                i1 = (i1 * (mk[j1] - (j2 >> 16))) / k3;
            }
            int j3 = j + k * yj;
            int l3 = yj - l;
            if(k < sk) {
                int i4 = sk - k;
                i1 -= i4;
                k = 0;
                j3 += i4 * yj;
                j2 += l2 * i4;
            }
            if(k + i1 >= tk)
                i1 -= ((k + i1) - tk) + 1;
            if(j < uk) {
                int j4 = uk - j;
                l -= j4;
                j = 0;
                j3 += j4;
                i2 += k2 * j4;
                l3 += j4;
            }
            if(j + l >= vk) {
                int k4 = ((j + l) - vk) + 1;
                l -= k4;
                l3 += k4;
            }
            byte byte0 = 1;
            if(wk) {
                byte0 = 2;
                l3 += yj;
                l2 += l2;
                if((k & 1) != 0) {
                    j3 += yj;
                    i1--;
                }
            }
            pf(ek, ik[j1], 0, i2, j2, j3, l3, l, i1, k2, l2, k1, byte0);
            return;
        }
        catch(Exception exception) {
            System.out.println("error in sprite clipping routine");
        }
    }

    public void qg(int j, int k, int l, int i1) {
        if(rk[l]) {
            j += nk[l];
            k += ok[l];
        }
        int j1 = j + k * yj;
        int k1 = 0;
        int l1 = mk[l];
        int i2 = lk[l];
        int j2 = yj - i2;
        int k2 = 0;
        if(k < sk) {
            int l2 = sk - k;
            l1 -= l2;
            k = sk;
            k1 += l2 * i2;
            j1 += l2 * yj;
        }
        if(k + l1 >= tk)
            l1 -= ((k + l1) - tk) + 1;
        if(j < uk) {
            int i3 = uk - j;
            i2 -= i3;
            j = uk;
            k1 += i3;
            j1 += i3;
            k2 += i3;
            j2 += i3;
        }
        if(j + i2 >= vk) {
            int j3 = ((j + i2) - vk) + 1;
            i2 -= j3;
            k2 += j3;
            j2 += j3;
        }
        if(i2 <= 0 || l1 <= 0)
            return;
        byte byte0 = 1;
        if(wk) {
            byte0 = 2;
            j2 += yj;
            k2 += lk[l];
            if((k & 1) != 0) {
                j1 += yj;
                l1--;
            }
        }
        if(ik[l] == null) {
            ch(ek, jk[l], kk[l], k1, j1, i2, l1, j2, k2, byte0, i1);
            return;
        } else {
            gg(ek, ik[l], 0, k1, j1, i2, l1, j2, k2, byte0, i1);
            return;
        }
    }

    public void pg(int j, int k, int l, int i1, int j1, int k1) {
        try {
            int l1 = lk[j1];
            int i2 = mk[j1];
            int j2 = 0;
            int k2 = 0;
            int l2 = (l1 << 16) / l;
            int i3 = (i2 << 16) / i1;
            if(rk[j1]) {
                int j3 = pk[j1];
                int l3 = qk[j1];
                l2 = (j3 << 16) / l;
                i3 = (l3 << 16) / i1;
                j += ((nk[j1] * l + j3) - 1) / j3;
                k += ((ok[j1] * i1 + l3) - 1) / l3;
                if((nk[j1] * l) % j3 != 0)
                    j2 = (j3 - (nk[j1] * l) % j3 << 16) / l;
                if((ok[j1] * i1) % l3 != 0)
                    k2 = (l3 - (ok[j1] * i1) % l3 << 16) / i1;
                l = (l * (lk[j1] - (j2 >> 16))) / j3;
                i1 = (i1 * (mk[j1] - (k2 >> 16))) / l3;
            }
            int k3 = j + k * yj;
            int i4 = yj - l;
            if(k < sk) {
                int j4 = sk - k;
                i1 -= j4;
                k = 0;
                k3 += j4 * yj;
                k2 += i3 * j4;
            }
            if(k + i1 >= tk)
                i1 -= ((k + i1) - tk) + 1;
            if(j < uk) {
                int k4 = uk - j;
                l -= k4;
                j = 0;
                k3 += k4;
                j2 += l2 * k4;
                i4 += k4;
            }
            if(j + l >= vk) {
                int l4 = ((j + l) - vk) + 1;
                l -= l4;
                i4 += l4;
            }
            byte byte0 = 1;
            if(wk) {
                byte0 = 2;
                i4 += yj;
                i3 += i3;
                if((k & 1) != 0) {
                    k3 += yj;
                    i1--;
                }
            }
            xf(ek, ik[j1], 0, j2, k2, k3, i4, l, i1, l2, i3, l1, byte0, k1);
            return;
        }
        catch(Exception exception) {
            System.out.println("error in sprite clipping routine");
        }
    }

    public void mg(int j, int k, int l, int i1, int j1, int k1) {
        try {
            int l1 = lk[j1];
            int i2 = mk[j1];
            int j2 = 0;
            int k2 = 0;
            int l2 = (l1 << 16) / l;
            int i3 = (i2 << 16) / i1;
            if(rk[j1]) {
                int j3 = pk[j1];
                int l3 = qk[j1];
                l2 = (j3 << 16) / l;
                i3 = (l3 << 16) / i1;
                j += ((nk[j1] * l + j3) - 1) / j3;
                k += ((ok[j1] * i1 + l3) - 1) / l3;
                if((nk[j1] * l) % j3 != 0)
                    j2 = (j3 - (nk[j1] * l) % j3 << 16) / l;
                if((ok[j1] * i1) % l3 != 0)
                    k2 = (l3 - (ok[j1] * i1) % l3 << 16) / i1;
                l = (l * (lk[j1] - (j2 >> 16))) / j3;
                i1 = (i1 * (mk[j1] - (k2 >> 16))) / l3;
            }
            int k3 = j + k * yj;
            int i4 = yj - l;
            if(k < sk) {
                int j4 = sk - k;
                i1 -= j4;
                k = 0;
                k3 += j4 * yj;
                k2 += i3 * j4;
            }
            if(k + i1 >= tk)
                i1 -= ((k + i1) - tk) + 1;
            if(j < uk) {
                int k4 = uk - j;
                l -= k4;
                j = 0;
                k3 += k4;
                j2 += l2 * k4;
                i4 += k4;
            }
            if(j + l >= vk) {
                int l4 = ((j + l) - vk) + 1;
                l -= l4;
                i4 += l4;
            }
            byte byte0 = 1;
            if(wk) {
                byte0 = 2;
                i4 += yj;
                i3 += i3;
                if((k & 1) != 0) {
                    k3 += yj;
                    i1--;
                }
            }
            eh(ek, ik[j1], 0, j2, k2, k3, i4, l, i1, l2, i3, l1, byte0, k1);
            return;
        }
        catch(Exception exception) {
            System.out.println("error in sprite clipping routine");
        }
    }

    private void gf(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2) {
        int j2 = -(i1 >> 2);
        i1 = -(i1 & 3);
        for(int k2 = -j1; k2 < 0; k2 += i2) {
            for(int l2 = j2; l2 < 0; l2++) {
                j = ai1[k++];
                if(j != 0)
                    ai[l++] = j;
                else
                    l++;
                j = ai1[k++];
                if(j != 0)
                    ai[l++] = j;
                else
                    l++;
                j = ai1[k++];
                if(j != 0)
                    ai[l++] = j;
                else
                    l++;
                j = ai1[k++];
                if(j != 0)
                    ai[l++] = j;
                else
                    l++;
            }

            for(int i3 = i1; i3 < 0; i3++) {
                j = ai1[k++];
                if(j != 0)
                    ai[l++] = j;
                else
                    l++;
            }

            l += k1;
            k += l1;
        }

    }

    private void cg(int ai[], byte abyte0[], int ai1[], int j, int k, int l, int i1, 
            int j1, int k1, int l1) {
        int i2 = -(l >> 2);
        l = -(l & 3);
        for(int j2 = -i1; j2 < 0; j2 += l1) {
            for(int k2 = i2; k2 < 0; k2++) {
                byte byte0 = abyte0[j++];
                if(byte0 != 0)
                    ai[k++] = ai1[byte0 & 0xff];
                else
                    k++;
                byte0 = abyte0[j++];
                if(byte0 != 0)
                    ai[k++] = ai1[byte0 & 0xff];
                else
                    k++;
                byte0 = abyte0[j++];
                if(byte0 != 0)
                    ai[k++] = ai1[byte0 & 0xff];
                else
                    k++;
                byte0 = abyte0[j++];
                if(byte0 != 0)
                    ai[k++] = ai1[byte0 & 0xff];
                else
                    k++;
            }

            for(int l2 = l; l2 < 0; l2++) {
                byte byte1 = abyte0[j++];
                if(byte1 != 0)
                    ai[k++] = ai1[byte1 & 0xff];
                else
                    k++;
            }

            k += j1;
            j += k1;
        }

    }

    private void pf(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2, int j2, int k2, int l2) {
        try {
            int i3 = k;
            for(int j3 = -l1; j3 < 0; j3 += l2) {
                int k3 = (l >> 16) * k2;
                for(int l3 = -k1; l3 < 0; l3++) {
                    j = ai1[(k >> 16) + k3];
                    if(j != 0)
                        ai[i1++] = j;
                    else
                        i1++;
                    k += i2;
                }

                l += j2;
                k = i3;
                i1 += j1;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in plot_scale");
        }
    }

    private void gg(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2, int j2) {
        int k2 = 256 - j2;
        for(int l2 = -j1; l2 < 0; l2 += i2) {
            for(int i3 = -i1; i3 < 0; i3++) {
                j = ai1[k++];
                if(j != 0) {
                    int j3 = ai[l];
                    ai[l++] = ((j & 0xff00ff) * j2 + (j3 & 0xff00ff) * k2 & 0xff00ff00) + ((j & 0xff00) * j2 + (j3 & 0xff00) * k2 & 0xff0000) >> 8;
                } else {
                    l++;
                }
            }

            l += k1;
            k += l1;
        }

    }

    private void ch(int ai[], byte abyte0[], int ai1[], int j, int k, int l, int i1, 
            int j1, int k1, int l1, int i2) {
        int j2 = 256 - i2;
        for(int k2 = -i1; k2 < 0; k2 += l1) {
            for(int l2 = -l; l2 < 0; l2++) {
                int i3 = abyte0[j++];
                if(i3 != 0) {
                    i3 = ai1[i3 & 0xff];
                    int j3 = ai[k];
                    ai[k++] = ((i3 & 0xff00ff) * i2 + (j3 & 0xff00ff) * j2 & 0xff00ff00) + ((i3 & 0xff00) * i2 + (j3 & 0xff00) * j2 & 0xff0000) >> 8;
                } else {
                    k++;
                }
            }

            k += j1;
            j += k1;
        }

    }

    private void xf(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2, int j2, int k2, int l2, int i3) {
        int j3 = 256 - i3;
        try {
            int k3 = k;
            for(int l3 = -l1; l3 < 0; l3 += l2) {
                int i4 = (l >> 16) * k2;
                for(int j4 = -k1; j4 < 0; j4++) {
                    j = ai1[(k >> 16) + i4];
                    if(j != 0) {
                        int k4 = ai[i1];
                        ai[i1++] = ((j & 0xff00ff) * i3 + (k4 & 0xff00ff) * j3 & 0xff00ff00) + ((j & 0xff00) * i3 + (k4 & 0xff00) * j3 & 0xff0000) >> 8;
                    } else {
                        i1++;
                    }
                    k += i2;
                }

                l += j2;
                k = k3;
                i1 += j1;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in tran_scale");
        }
    }

    private void eh(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2, int j2, int k2, int l2, int i3) {
        int j3 = i3 >> 16 & 0xff;
        int k3 = i3 >> 8 & 0xff;
        int l3 = i3 & 0xff;
        try {
            int i4 = k;
            for(int j4 = -l1; j4 < 0; j4 += l2) {
                int k4 = (l >> 16) * k2;
                for(int l4 = -k1; l4 < 0; l4++) {
                    j = ai1[(k >> 16) + k4];
                    if(j != 0) {
                        int i5 = j >> 16 & 0xff;
                        int j5 = j >> 8 & 0xff;
                        int k5 = j & 0xff;
                        if(i5 == j5 && j5 == k5)
                            ai[i1++] = ((i5 * j3 >> 8) << 16) + ((j5 * k3 >> 8) << 8) + (k5 * l3 >> 8);
                        else
                            ai[i1++] = j;
                    } else {
                        i1++;
                    }
                    k += i2;
                }

                l += j2;
                k = i4;
                i1 += j1;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in plot_scale");
        }
    }

    public void of(int j, int k, int l, int i1, int j1) {
        int k1 = yj;
        int l1 = zj;
        if(bl == null) {
            bl = new int[512];
            for(int i2 = 0; i2 < 256; i2++) {
                bl[i2] = (int)(Math.sin((double)i2 * 0.02454369D) * 32768D);
                bl[i2 + 256] = (int)(Math.cos((double)i2 * 0.02454369D) * 32768D);
            }

        }
        int j2 = -pk[l] / 2;
        int k2 = -qk[l] / 2;
        if(rk[l]) {
            j2 += nk[l];
            k2 += ok[l];
        }
        int l2 = j2 + lk[l];
        int i3 = k2 + mk[l];
        int j3 = l2;
        int k3 = k2;
        int l3 = j2;
        int i4 = i3;
        i1 &= 0xff;
        int j4 = bl[i1] * j1;
        int k4 = bl[i1 + 256] * j1;
        int l4 = j + (k2 * j4 + j2 * k4 >> 22);
        int i5 = k + (k2 * k4 - j2 * j4 >> 22);
        int j5 = j + (k3 * j4 + j3 * k4 >> 22);
        int k5 = k + (k3 * k4 - j3 * j4 >> 22);
        int l5 = j + (i3 * j4 + l2 * k4 >> 22);
        int i6 = k + (i3 * k4 - l2 * j4 >> 22);
        int j6 = j + (i4 * j4 + l3 * k4 >> 22);
        int k6 = k + (i4 * k4 - l3 * j4 >> 22);
        int l6 = i5;
        int i7 = i5;
        if(k5 < l6)
            l6 = k5;
        else
        if(k5 > i7)
            i7 = k5;
        if(i6 < l6)
            l6 = i6;
        else
        if(i6 > i7)
            i7 = i6;
        if(k6 < l6)
            l6 = k6;
        else
        if(k6 > i7)
            i7 = k6;
        if(l6 < sk)
            l6 = sk;
        if(i7 > tk)
            i7 = tk;
        if(cl == null || cl.length != l1 + 1) {
            cl = new int[l1 + 1];
            dl = new int[l1 + 1];
            el = new int[l1 + 1];
            fl = new int[l1 + 1];
            gl = new int[l1 + 1];
            hl = new int[l1 + 1];
        }
        for(int j7 = l6; j7 <= i7; j7++) {
            cl[j7] = 0x5f5e0ff;
            dl[j7] = 0xfa0a1f01;
        }

        int k7 = 0;
        int l7 = 0;
        int i8 = 0;
        int j8 = lk[l];
        int k8 = mk[l];
        j2 = 0;
        k2 = 0;
        j3 = j8 - 1;
        k3 = 0;
        l2 = j8 - 1;
        i3 = k8 - 1;
        l3 = 0;
        i4 = k8 - 1;
        if(k6 != i5) {
            k7 = (j6 - l4 << 8) / (k6 - i5);
            i8 = (i4 - k2 << 8) / (k6 - i5);
        }
        int l8;
        int i9;
        int j9;
        int k9;
        if(i5 > k6) {
            j9 = j6 << 8;
            k9 = i4 << 8;
            l8 = k6;
            i9 = i5;
        } else {
            j9 = l4 << 8;
            k9 = k2 << 8;
            l8 = i5;
            i9 = k6;
        }
        if(l8 < 0) {
            j9 -= k7 * l8;
            k9 -= i8 * l8;
            l8 = 0;
        }
        if(i9 > l1 - 1)
            i9 = l1 - 1;
        for(int l9 = l8; l9 <= i9; l9++) {
            cl[l9] = dl[l9] = j9;
            j9 += k7;
            el[l9] = fl[l9] = 0;
            gl[l9] = hl[l9] = k9;
            k9 += i8;
        }

        if(k5 != i5) {
            k7 = (j5 - l4 << 8) / (k5 - i5);
            l7 = (j3 - j2 << 8) / (k5 - i5);
        }
        int i10;
        if(i5 > k5) {
            j9 = j5 << 8;
            i10 = j3 << 8;
            l8 = k5;
            i9 = i5;
        } else {
            j9 = l4 << 8;
            i10 = j2 << 8;
            l8 = i5;
            i9 = k5;
        }
        if(l8 < 0) {
            j9 -= k7 * l8;
            i10 -= l7 * l8;
            l8 = 0;
        }
        if(i9 > l1 - 1)
            i9 = l1 - 1;
        for(int j10 = l8; j10 <= i9; j10++) {
            if(j9 < cl[j10]) {
                cl[j10] = j9;
                el[j10] = i10;
                gl[j10] = 0;
            }
            if(j9 > dl[j10]) {
                dl[j10] = j9;
                fl[j10] = i10;
                hl[j10] = 0;
            }
            j9 += k7;
            i10 += l7;
        }

        if(i6 != k5) {
            k7 = (l5 - j5 << 8) / (i6 - k5);
            i8 = (i3 - k3 << 8) / (i6 - k5);
        }
        if(k5 > i6) {
            j9 = l5 << 8;
            i10 = l2 << 8;
            k9 = i3 << 8;
            l8 = i6;
            i9 = k5;
        } else {
            j9 = j5 << 8;
            i10 = j3 << 8;
            k9 = k3 << 8;
            l8 = k5;
            i9 = i6;
        }
        if(l8 < 0) {
            j9 -= k7 * l8;
            k9 -= i8 * l8;
            l8 = 0;
        }
        if(i9 > l1 - 1)
            i9 = l1 - 1;
        for(int k10 = l8; k10 <= i9; k10++) {
            if(j9 < cl[k10]) {
                cl[k10] = j9;
                el[k10] = i10;
                gl[k10] = k9;
            }
            if(j9 > dl[k10]) {
                dl[k10] = j9;
                fl[k10] = i10;
                hl[k10] = k9;
            }
            j9 += k7;
            k9 += i8;
        }

        if(k6 != i6) {
            k7 = (j6 - l5 << 8) / (k6 - i6);
            l7 = (l3 - l2 << 8) / (k6 - i6);
        }
        if(i6 > k6) {
            j9 = j6 << 8;
            i10 = l3 << 8;
            k9 = i4 << 8;
            l8 = k6;
            i9 = i6;
        } else {
            j9 = l5 << 8;
            i10 = l2 << 8;
            k9 = i3 << 8;
            l8 = i6;
            i9 = k6;
        }
        if(l8 < 0) {
            j9 -= k7 * l8;
            i10 -= l7 * l8;
            l8 = 0;
        }
        if(i9 > l1 - 1)
            i9 = l1 - 1;
        for(int l10 = l8; l10 <= i9; l10++) {
            if(j9 < cl[l10]) {
                cl[l10] = j9;
                el[l10] = i10;
                gl[l10] = k9;
            }
            if(j9 > dl[l10]) {
                dl[l10] = j9;
                fl[l10] = i10;
                hl[l10] = k9;
            }
            j9 += k7;
            i10 += l7;
        }

        int i11 = l6 * k1;
        int ai[] = ik[l];
        for(int j11 = l6; j11 < i7; j11++) {
            int k11 = cl[j11] >> 8;
            int l11 = dl[j11] >> 8;
            if(l11 - k11 <= 0) {
                i11 += k1;
            } else {
                int i12 = el[j11] << 9;
                int j12 = ((fl[j11] << 9) - i12) / (l11 - k11);
                int k12 = gl[j11] << 9;
                int l12 = ((hl[j11] << 9) - k12) / (l11 - k11);
                if(k11 < uk) {
                    i12 += (uk - k11) * j12;
                    k12 += (uk - k11) * l12;
                    k11 = uk;
                }
                if(l11 > vk)
                    l11 = vk;
                if(!wk || (j11 & 1) == 0)
                    if(!rk[l])
                        ag(ek, ai, 0, i11 + k11, i12, k12, j12, l12, k11 - l11, j8);
                    else
                        eg(ek, ai, 0, i11 + k11, i12, k12, j12, l12, k11 - l11, j8);
                i11 += k1;
            }
        }

    }

    private void ag(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2) {
        for(j = l1; j < 0; j++) {
            ek[k++] = ai1[(l >> 17) + (i1 >> 17) * i2];
            l += j1;
            i1 += k1;
        }

    }

    private void eg(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2) {
        for(int j2 = l1; j2 < 0; j2++) {
            j = ai1[(l >> 17) + (i1 >> 17) * i2];
            if(j != 0)
                ek[k++] = j;
            else
                k++;
            l += j1;
            i1 += k1;
        }

    }

    public void dg(int j, int k, int l, int i1, int j1, int k1, int l1) {
        nf(j, k, l, i1, j1);
    }

    public void wf(int j, int k, int l, int i1, int j1, int k1, int l1, 
            int i2, boolean flag) {
        try {
            if(k1 == 0)
                k1 = 0xffffff;
            if(l1 == 0)
                l1 = 0xffffff;
            int j2 = lk[j1];
            int k2 = mk[j1];
            int l2 = 0;
            int i3 = 0;
            int j3 = i2 << 16;
            int k3 = (j2 << 16) / l;
            int l3 = (k2 << 16) / i1;
            int i4 = -(i2 << 16) / i1;
            if(rk[j1]) {
                int j4 = pk[j1];
                int l4 = qk[j1];
                k3 = (j4 << 16) / l;
                l3 = (l4 << 16) / i1;
                int k5 = nk[j1];
                int l5 = ok[j1];
                if(flag)
                    k5 = j4 - lk[j1] - k5;
                j += ((k5 * l + j4) - 1) / j4;
                int i6 = ((l5 * i1 + l4) - 1) / l4;
                k += i6;
                j3 += i6 * i4;
                if((k5 * l) % j4 != 0)
                    l2 = (j4 - (k5 * l) % j4 << 16) / l;
                if((l5 * i1) % l4 != 0)
                    i3 = (l4 - (l5 * i1) % l4 << 16) / i1;
                l = ((((lk[j1] << 16) - l2) + k3) - 1) / k3;
                i1 = ((((mk[j1] << 16) - i3) + l3) - 1) / l3;
            }
            int k4 = k * yj;
            j3 += j << 16;
            if(k < sk) {
                int i5 = sk - k;
                i1 -= i5;
                k = sk;
                k4 += i5 * yj;
                i3 += l3 * i5;
                j3 += i4 * i5;
            }
            if(k + i1 >= tk)
                i1 -= ((k + i1) - tk) + 1;
            int j5 = k4 / yj & 1;
            if(!wk)
                j5 = 2;
            if(l1 == 0xffffff) {
                if(ik[j1] != null)
                    if(!flag) {
                        dh(ek, ik[j1], 0, l2, i3, k4, l, i1, k3, l3, j2, k1, j3, i4, j5);
                        return;
                    } else {
                        dh(ek, ik[j1], 0, (lk[j1] << 16) - l2 - 1, i3, k4, l, i1, -k3, l3, j2, k1, j3, i4, j5);
                        return;
                    }
                if(!flag) {
                    _mthif(ek, jk[j1], kk[j1], 0, l2, i3, k4, l, i1, k3, l3, j2, k1, j3, i4, j5);
                    return;
                } else {
                    _mthif(ek, jk[j1], kk[j1], 0, (lk[j1] << 16) - l2 - 1, i3, k4, l, i1, -k3, l3, j2, k1, j3, i4, j5);
                    return;
                }
            }
            if(ik[j1] != null)
                if(!flag) {
                    bg(ek, ik[j1], 0, l2, i3, k4, l, i1, k3, l3, j2, k1, l1, j3, i4, j5);
                    return;
                } else {
                    bg(ek, ik[j1], 0, (lk[j1] << 16) - l2 - 1, i3, k4, l, i1, -k3, l3, j2, k1, l1, j3, i4, j5);
                    return;
                }
            if(!flag) {
                bh(ek, jk[j1], kk[j1], 0, l2, i3, k4, l, i1, k3, l3, j2, k1, l1, j3, i4, j5);
                return;
            } else {
                bh(ek, jk[j1], kk[j1], 0, (lk[j1] << 16) - l2 - 1, i3, k4, l, i1, -k3, l3, j2, k1, l1, j3, i4, j5);
                return;
            }
        }
        catch(Exception exception) {
            System.out.println("error in sprite clipping routine");
        }
    }

    private void dh(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2, int j2, int k2, int l2, int i3, 
            int j3) {
        int k3 = k2 >> 16 & 0xff;
        int l3 = k2 >> 8 & 0xff;
        int i4 = k2 & 0xff;
        try {
            int j4 = k;
            for(int k4 = -k1; k4 < 0; k4++) {
                int l4 = (l >> 16) * j2;
                int i5 = l2 >> 16;
                int j5 = j1;
                if(i5 < uk) {
                    int k5 = uk - i5;
                    j5 -= k5;
                    i5 = uk;
                    k += l1 * k5;
                }
                if(i5 + j5 >= vk) {
                    int l5 = (i5 + j5) - vk;
                    j5 -= l5;
                }
                j3 = 1 - j3;
                if(j3 != 0) {
                    for(int i6 = i5; i6 < i5 + j5; i6++) {
                        j = ai1[(k >> 16) + l4];
                        if(j != 0) {
                            int j6 = j >> 16 & 0xff;
                            int k6 = j >> 8 & 0xff;
                            int l6 = j & 0xff;
                            if(j6 == k6 && k6 == l6)
                                ai[i6 + i1] = ((j6 * k3 >> 8) << 16) + ((k6 * l3 >> 8) << 8) + (l6 * i4 >> 8);
                            else
                                ai[i6 + i1] = j;
                        }
                        k += l1;
                    }

                }
                l += i2;
                k = j4;
                i1 += yj;
                l2 += i3;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in transparent sprite plot routine");
        }
    }

    private void bg(int ai[], int ai1[], int j, int k, int l, int i1, int j1, 
            int k1, int l1, int i2, int j2, int k2, int l2, int i3, 
            int j3, int k3) {
        int l3 = k2 >> 16 & 0xff;
        int i4 = k2 >> 8 & 0xff;
        int j4 = k2 & 0xff;
        int k4 = l2 >> 16 & 0xff;
        int l4 = l2 >> 8 & 0xff;
        int i5 = l2 & 0xff;
        try {
            int j5 = k;
            for(int k5 = -k1; k5 < 0; k5++) {
                int l5 = (l >> 16) * j2;
                int i6 = i3 >> 16;
                int j6 = j1;
                if(i6 < uk) {
                    int k6 = uk - i6;
                    j6 -= k6;
                    i6 = uk;
                    k += l1 * k6;
                }
                if(i6 + j6 >= vk) {
                    int l6 = (i6 + j6) - vk;
                    j6 -= l6;
                }
                k3 = 1 - k3;
                if(k3 != 0) {
                    for(int i7 = i6; i7 < i6 + j6; i7++) {
                        j = ai1[(k >> 16) + l5];
                        if(j != 0) {
                            int j7 = j >> 16 & 0xff;
                            int k7 = j >> 8 & 0xff;
                            int l7 = j & 0xff;
                            if(j7 == k7 && k7 == l7)
                                ai[i7 + i1] = ((j7 * l3 >> 8) << 16) + ((k7 * i4 >> 8) << 8) + (l7 * j4 >> 8);
                            else
                            if(j7 == 255 && k7 == l7)
                                ai[i7 + i1] = ((j7 * k4 >> 8) << 16) + ((k7 * l4 >> 8) << 8) + (l7 * i5 >> 8);
                            else
                                ai[i7 + i1] = j;
                        }
                        k += l1;
                    }

                }
                l += i2;
                k = j5;
                i1 += yj;
                i3 += j3;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in transparent sprite plot routine");
        }
    }

    private void _mthif(int ai[], byte abyte0[], int ai1[], int j, int k, int l, int i1, 
            int j1, int k1, int l1, int i2, int j2, int k2, int l2, 
            int i3, int j3) {
        int k3 = k2 >> 16 & 0xff;
        int l3 = k2 >> 8 & 0xff;
        int i4 = k2 & 0xff;
        try {
            int j4 = k;
            for(int k4 = -k1; k4 < 0; k4++) {
                int l4 = (l >> 16) * j2;
                int i5 = l2 >> 16;
                int j5 = j1;
                if(i5 < uk) {
                    int k5 = uk - i5;
                    j5 -= k5;
                    i5 = uk;
                    k += l1 * k5;
                }
                if(i5 + j5 >= vk) {
                    int l5 = (i5 + j5) - vk;
                    j5 -= l5;
                }
                j3 = 1 - j3;
                if(j3 != 0) {
                    for(int i6 = i5; i6 < i5 + j5; i6++) {
                        j = abyte0[(k >> 16) + l4] & 0xff;
                        if(j != 0) {
                            j = ai1[j];
                            int j6 = j >> 16 & 0xff;
                            int k6 = j >> 8 & 0xff;
                            int l6 = j & 0xff;
                            if(j6 == k6 && k6 == l6)
                                ai[i6 + i1] = ((j6 * k3 >> 8) << 16) + ((k6 * l3 >> 8) << 8) + (l6 * i4 >> 8);
                            else
                                ai[i6 + i1] = j;
                        }
                        k += l1;
                    }

                }
                l += i2;
                k = j4;
                i1 += yj;
                l2 += i3;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in transparent sprite plot routine");
        }
    }

    private void bh(int ai[], byte abyte0[], int ai1[], int j, int k, int l, int i1, 
            int j1, int k1, int l1, int i2, int j2, int k2, int l2, 
            int i3, int j3, int k3) {
        int l3 = k2 >> 16 & 0xff;
        int i4 = k2 >> 8 & 0xff;
        int j4 = k2 & 0xff;
        int k4 = l2 >> 16 & 0xff;
        int l4 = l2 >> 8 & 0xff;
        int i5 = l2 & 0xff;
        try {
            int j5 = k;
            for(int k5 = -k1; k5 < 0; k5++) {
                int l5 = (l >> 16) * j2;
                int i6 = i3 >> 16;
                int j6 = j1;
                if(i6 < uk) {
                    int k6 = uk - i6;
                    j6 -= k6;
                    i6 = uk;
                    k += l1 * k6;
                }
                if(i6 + j6 >= vk) {
                    int l6 = (i6 + j6) - vk;
                    j6 -= l6;
                }
                k3 = 1 - k3;
                if(k3 != 0) {
                    for(int i7 = i6; i7 < i6 + j6; i7++) {
                        j = abyte0[(k >> 16) + l5] & 0xff;
                        if(j != 0) {
                            j = ai1[j];
                            int j7 = j >> 16 & 0xff;
                            int k7 = j >> 8 & 0xff;
                            int l7 = j & 0xff;
                            if(j7 == k7 && k7 == l7)
                                ai[i7 + i1] = ((j7 * l3 >> 8) << 16) + ((k7 * i4 >> 8) << 8) + (l7 * j4 >> 8);
                            else
                            if(j7 == 255 && k7 == l7)
                                ai[i7 + i1] = ((j7 * k4 >> 8) << 16) + ((k7 * l4 >> 8) << 8) + (l7 * i5 >> 8);
                            else
                                ai[i7 + i1] = j;
                        }
                        k += l1;
                    }

                }
                l += i2;
                k = j5;
                i1 += yj;
                i3 += j3;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("error in transparent sprite plot routine");
        }
    }

    public static int ef(byte abyte0[]) {
        xk[zk] = abyte0;
        return zk++;
    }

    public void yg(String s, int j, int k, int l, int i1) {
        mf(s, j - df(s, l), k, l, i1);
    }

    public void ug(String s, int j, int k, int l, int i1) {
        mf(s, j - df(s, l) / 2, k, l, i1);
    }

    public void ah(String s, int j, int k, int l, int i1, int j1) {
        try {
            int k1 = 0;
            byte abyte0[] = xk[l];
            int l1 = 0;
            int i2 = 0;
            for(int j2 = 0; j2 < s.length(); j2++) {
                if(s.charAt(j2) == '@' && j2 + 4 < s.length() && s.charAt(j2 + 4) == '@')
                    j2 += 4;
                else
                if(s.charAt(j2) == '~' && j2 + 4 < s.length() && s.charAt(j2 + 4) == '~')
                    j2 += 4;
                else
                    k1 += abyte0[yk[s.charAt(j2)] + 7];
                if(s.charAt(j2) == ' ')
                    i2 = j2;
                if(k1 > j1) {
                    if(i2 <= l1)
                        i2 = j2;
                    ug(s.substring(l1, i2), j, k, l, i1);
                    k1 = 0;
                    l1 = j2 = i2 + 1;
                    k += ng(l);
                }
            }

            if(k1 > 0) {
                ug(s.substring(l1), j, k, l, i1);
                return;
            }
        }
        catch(Exception exception) {
            System.out.println("centrepara: " + exception);
            exception.printStackTrace();
        }
    }

    public void mf(String s, int j, int k, int l, int i1) {
        try {
            byte abyte0[] = xk[l];
            for(int j1 = 0; j1 < s.length(); j1++)
                if(s.charAt(j1) == '@' && j1 + 4 < s.length() && s.charAt(j1 + 4) == '@') {
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("red"))
                        i1 = 0xff0000;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("lre"))
                        i1 = 0xff9040;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("yel"))
                        i1 = 0xffff00;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("gre"))
                        i1 = 65280;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("blu"))
                        i1 = 255;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("cya"))
                        i1 = 65535;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("mag"))
                        i1 = 0xff00ff;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("whi"))
                        i1 = 0xffffff;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("bla"))
                        i1 = 0;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("dre"))
                        i1 = 0xc00000;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("ora"))
                        i1 = 0xff9040;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("ran"))
                        i1 = (int)(Math.random() * 16777215D);
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("or1"))
                        i1 = 0xffb000;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("or2"))
                        i1 = 0xff7000;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("or3"))
                        i1 = 0xff3000;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("gr1"))
                        i1 = 0xc0ff00;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("gr2"))
                        i1 = 0x80ff00;
                    else
                    if(s.substring(j1 + 1, j1 + 4).equalsIgnoreCase("gr3"))
                        i1 = 0x40ff00;
                    j1 += 4;
                } else
                if(s.charAt(j1) == '~' && j1 + 4 < s.length() && s.charAt(j1 + 4) == '~') {
                    char c = s.charAt(j1 + 1);
                    char c1 = s.charAt(j1 + 2);
                    char c2 = s.charAt(j1 + 3);
                    if(c >= '0' && c <= '9' && c1 >= '0' && c1 <= '9' && c2 >= '0' && c2 <= '9')
                        j = Integer.parseInt(s.substring(j1 + 1, j1 + 4));
                    j1 += 4;
                } else {
                    int k1 = yk[s.charAt(j1)];
                    if(al && i1 != 0)
                        tg(k1, j + 1, k, 0, abyte0);
                    if(al && i1 != 0)
                        tg(k1, j, k + 1, 0, abyte0);
                    tg(k1, j, k, i1, abyte0);
                    j += abyte0[k1 + 7];
                }

            return;
        }
        catch(Exception exception) {
            System.out.println("drawstring: " + exception);
            exception.printStackTrace();
            return;
        }
    }

    private void tg(int j, int k, int l, int i1, byte abyte0[]) {
        int j1 = k + abyte0[j + 5];
        int k1 = l - abyte0[j + 6];
        int l1 = abyte0[j + 3];
        int i2 = abyte0[j + 4];
        int j2 = abyte0[j] * 16384 + abyte0[j + 1] * 128 + abyte0[j + 2];
        int k2 = j1 + k1 * yj;
        int l2 = yj - l1;
        int i3 = 0;
        if(k1 < sk) {
            int j3 = sk - k1;
            i2 -= j3;
            k1 = sk;
            j2 += j3 * l1;
            k2 += j3 * yj;
        }
        if(k1 + i2 >= tk)
            i2 -= ((k1 + i2) - tk) + 1;
        if(j1 < uk) {
            int k3 = uk - j1;
            l1 -= k3;
            j1 = uk;
            j2 += k3;
            k2 += k3;
            i3 += k3;
            l2 += k3;
        }
        if(j1 + l1 >= vk) {
            int l3 = ((j1 + l1) - vk) + 1;
            l1 -= l3;
            i3 += l3;
            l2 += l3;
        }
        if(l1 > 0 && i2 > 0)
            cf(ek, abyte0, i1, j2, k2, l1, i2, l2, i3);
    }

    private void cf(int ai[], byte abyte0[], int j, int k, int l, int i1, int j1, 
            int k1, int l1) {
        try {
            int i2 = -(i1 >> 2);
            i1 = -(i1 & 3);
            for(int j2 = -j1; j2 < 0; j2++) {
                for(int k2 = i2; k2 < 0; k2++) {
                    if(abyte0[k++] != 0)
                        ai[l++] = j;
                    else
                        l++;
                    if(abyte0[k++] != 0)
                        ai[l++] = j;
                    else
                        l++;
                    if(abyte0[k++] != 0)
                        ai[l++] = j;
                    else
                        l++;
                    if(abyte0[k++] != 0)
                        ai[l++] = j;
                    else
                        l++;
                }

                for(int l2 = i1; l2 < 0; l2++)
                    if(abyte0[k++] != 0)
                        ai[l++] = j;
                    else
                        l++;

                l += k1;
                k += l1;
            }

            return;
        }
        catch(Exception exception) {
            System.out.println("plotletter: " + exception);
            exception.printStackTrace();
            return;
        }
    }

    public int ng(int j) {
        if(j == 0)
            return xk[j][8] - 2;
        else
            return xk[j][8] - 1;
    }

    public int df(String s, int j) {
        int k = 0;
        byte abyte0[] = xk[j];
        for(int l = 0; l < s.length(); l++)
            if(s.charAt(l) == '@' && l + 4 < s.length() && s.charAt(l + 4) == '@')
                l += 4;
            else
            if(s.charAt(l) == '~' && l + 4 < s.length() && s.charAt(l + 4) == '~')
                l += 4;
            else
                k += abyte0[yk[s.charAt(l)] + 7];

        return k;
    }

    public boolean imageUpdate(Image image, int j, int k, int l, int i1, int j1) {
        return true;
    }

    public static final int xj = 0;
    public int yj;
    public int zj;
    public int ak;
    public int bk;
    public int ck;
    ColorModel dk;
    public int ek[];
    ImageConsumer fk;
    private Component gk;
    public Image hk;
    public int ik[][];
    public byte jk[][];
    public int kk[][];
    public int lk[];
    public int mk[];
    public int nk[];
    public int ok[];
    public int pk[];
    public int qk[];
    public boolean rk[];
    private int sk;
    private int tk;
    private int uk;
    private int vk;
    public boolean wk;
    static byte xk[][] = new byte[50][];
    static int yk[];
    static int zk;
    public boolean al;
    int bl[];
    int cl[];
    int dl[];
    int el[];
    int fl[];
    int gl[];
    int hl[];
    public static final int il = 0;
    public static final int jl = 0xffffff;
    public static final int kl = 0xff0000;
    public static final int ll = 0xc00000;
    public static final int ml = 65280;
    public static final int nl = 255;
    public static final int ol = 0xffff00;
    public static final int pl = 65535;
    public static final int ql = 0xff00ff;
    public static final int rl = 0xc0c0c0;
    public static final int sl = 0x808080;
    public static final int tl = 0x404040;
    public static final int ul = 0xff8000;
    public static final int vl = 0;
    public static final int wl = 1;
    public static final int xl = 3;
    public static final int yl = 4;
    public static final int zl = 5;
    public static final int am = 7;

    static  {
        String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!\"\243$%^&*()-_=+[{]};:'@#~,<.>/?\\| ";
        yk = new int[256];
        for(int j = 0; j < 256; j++) {
            int k = s.indexOf(j);
            if(k == -1)
                k = 74;
            yk[j] = k * 9;
        }

    }
}